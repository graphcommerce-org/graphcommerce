diff --git a/node_modules/@types/react/index.d.ts b/node_modules/@types/react/index.d.ts
index f33dff8..d9a8003 100755
--- a/node_modules/@types/react/index.d.ts
+++ b/node_modules/@types/react/index.d.ts
@@ -76,7 +76,7 @@ declare namespace React {
     type ComponentType<P = {}> = ComponentClass<P> | FunctionComponent<P>;
 
     type JSXElementConstructor<P> =
-        | ((props: P) => ReactElement<any, any> | null)
+        | ((props: P) => ReactNode)
         | (new (props: P) => Component<any, any>);
 
     interface RefObject<T> {
@@ -107,7 +107,7 @@ declare namespace React {
         C extends
             | ForwardRefExoticComponent<any>
             | { new (props: any): Component<any> }
-            | ((props: any, context?: any) => ReactElement | null)
+            | ((props: any, context?: any) => ReactNode)
             | keyof JSX.IntrinsicElements
     > =
         // need to check first if `ref` is a valid prop for ts@3.0
@@ -374,7 +374,7 @@ declare namespace React {
         /**
          * **NOTE**: Exotic components are not callable.
          */
-        (props: P): (ReactElement|null);
+        (props: P): ReactNode;
         readonly $$typeof: symbol;
     }
 
@@ -544,7 +544,7 @@ declare namespace React {
     type FC<P = {}> = FunctionComponent<P>;
 
     interface FunctionComponent<P = {}> {
-        (props: P, context?: any): ReactElement<any, any> | null;
+        (props: P, context?: any): ReactNode;
         propTypes?: WeakValidationMap<P> | undefined;
         contextTypes?: ValidationMap<any> | undefined;
         defaultProps?: Partial<P> | undefined;
@@ -560,7 +560,7 @@ declare namespace React {
      * @deprecated - Equivalent with `React.FunctionComponent`.
      */
     interface VoidFunctionComponent<P = {}> {
-        (props: P, context?: any): ReactElement<any, any> | null;
+        (props: P, context?: any): ReactNode;
         propTypes?: WeakValidationMap<P> | undefined;
         contextTypes?: ValidationMap<any> | undefined;
         defaultProps?: Partial<P> | undefined;
@@ -570,7 +570,7 @@ declare namespace React {
     type ForwardedRef<T> = ((instance: T | null) => void) | MutableRefObject<T | null> | null;
 
     interface ForwardRefRenderFunction<T, P = {}> {
-        (props: P, ref: ForwardedRef<T>): ReactElement | null;
+        (props: P, ref: ForwardedRef<T>): ReactNode;
         displayName?: string | undefined;
         // explicit rejected with `never` required due to
         // https://github.com/microsoft/TypeScript/issues/36826
@@ -3119,7 +3119,9 @@ declare namespace React {
         componentStack: string;
     }
 
+    // Keep in sync with JSX namespace in ./jsx-runtime.d.ts and ./jsx-dev-runtime.d.ts
     namespace JSX {
+        type ElementType = GlobalJSXElementType;
         interface Element extends GlobalJSXElement {}
         interface ElementClass extends GlobalJSXElementClass {}
         interface ElementAttributesProperty extends GlobalJSXElementAttributesProperty {}
@@ -3182,6 +3184,18 @@ declare global {
      * @deprecated Use `React.JSX` instead of the global `JSX` namespace.
      */
     namespace JSX {
+        // We don't just alias React.ElementType because React.ElementType
+        // historically does more than we need it to.
+        // E.g. it also contains .propTypes and so TS also verifies the declared
+        // props type does match the declared .propTypes.
+        // But if libraries declared their .propTypes but not props type,
+        // or they mismatch, you won't be able to use the class component
+        // as a JSX.ElementType.
+        // We could fix this everywhere but we're ultimately not interested in
+        // .propTypes assignability so we might as well drop it entirely here to
+        //  reduce the work of the type-checker.
+        // TODO: Check impact of making React.ElementType<P = any> = React.JSXElementConstructor<P>
+        type ElementType = string | React.JSXElementConstructor<any>;
         interface Element extends React.ReactElement<any, any> { }
         interface ElementClass extends React.Component<any> {
             render(): React.ReactNode;
@@ -3388,6 +3402,7 @@ declare global {
 // React.JSX needs to point to global.JSX to keep global module augmentations intact.
 // But we can't access global.JSX so we need to create these aliases instead.
 // Once the global JSX namespace will be removed we replace React.JSX with the contents of global.JSX
+type GlobalJSXElementType = JSX.ElementType;
 interface GlobalJSXElement extends JSX.Element {}
 interface GlobalJSXElementClass extends JSX.ElementClass {}
 interface GlobalJSXElementAttributesProperty extends JSX.ElementAttributesProperty {}
diff --git a/node_modules/@types/react/jsx-dev-runtime.d.ts b/node_modules/@types/react/jsx-dev-runtime.d.ts
index be717f4..dc5ec6d 100755
--- a/node_modules/@types/react/jsx-dev-runtime.d.ts
+++ b/node_modules/@types/react/jsx-dev-runtime.d.ts
@@ -1,6 +1,7 @@
 import * as React from './';
 
 export namespace JSX {
+    type ElementType = React.JSX.ElementType;
     interface Element extends React.JSX.Element {}
     interface ElementClass extends React.JSX.ElementClass {}
     interface ElementAttributesProperty extends React.JSX.ElementAttributesProperty {}
diff --git a/node_modules/@types/react/jsx-runtime.d.ts b/node_modules/@types/react/jsx-runtime.d.ts
index be717f4..62eaf2a 100755
--- a/node_modules/@types/react/jsx-runtime.d.ts
+++ b/node_modules/@types/react/jsx-runtime.d.ts
@@ -1,6 +1,7 @@
 import * as React from './';
 
 export namespace JSX {
+    type ElementType = React.JSX.ElementType;
     interface Element extends React.JSX.Element {}
     interface ElementClass extends React.JSX.ElementClass {}
     interface ElementAttributesProperty extends React.JSX.ElementAttributesProperty {}
diff --git a/node_modules/@types/react/ts5.0/index.d.ts b/node_modules/@types/react/ts5.0/index.d.ts
index b506372..fa50e21 100755
--- a/node_modules/@types/react/ts5.0/index.d.ts
+++ b/node_modules/@types/react/ts5.0/index.d.ts
@@ -44,7 +44,7 @@ declare namespace React {
     type ComponentType<P = {}> = ComponentClass<P> | FunctionComponent<P>;
 
     type JSXElementConstructor<P> =
-        | ((props: P) => ReactElement<any, any> | null)
+        | ((props: P) => ReactNode)
         | (new (props: P) => Component<any, any>);
 
     interface RefObject<T> {
@@ -75,7 +75,7 @@ declare namespace React {
         C extends
             | ForwardRefExoticComponent<any>
             | { new (props: any): Component<any> }
-            | ((props: any, context?: any) => ReactElement | null)
+            | ((props: any, context?: any) => ReactNode)
             | keyof JSX.IntrinsicElements
     > =
         // need to check first if `ref` is a valid prop for ts@3.0
@@ -342,7 +342,7 @@ declare namespace React {
         /**
          * **NOTE**: Exotic components are not callable.
          */
-        (props: P): (ReactElement|null);
+        (props: P): ReactNode;
         readonly $$typeof: symbol;
     }
 
@@ -512,7 +512,7 @@ declare namespace React {
     type FC<P = {}> = FunctionComponent<P>;
 
     interface FunctionComponent<P = {}> {
-        (props: P, context?: any): ReactElement<any, any> | null;
+        (props: P, context?: any): ReactNode;
         propTypes?: WeakValidationMap<P> | undefined;
         contextTypes?: ValidationMap<any> | undefined;
         defaultProps?: Partial<P> | undefined;
@@ -528,7 +528,7 @@ declare namespace React {
      * @deprecated - Equivalent with `React.FunctionComponent`.
      */
     interface VoidFunctionComponent<P = {}> {
-        (props: P, context?: any): ReactElement<any, any> | null;
+        (props: P, context?: any): ReactNode;
         propTypes?: WeakValidationMap<P> | undefined;
         contextTypes?: ValidationMap<any> | undefined;
         defaultProps?: Partial<P> | undefined;
@@ -538,7 +538,7 @@ declare namespace React {
     type ForwardedRef<T> = ((instance: T | null) => void) | MutableRefObject<T | null> | null;
 
     interface ForwardRefRenderFunction<T, P = {}> {
-        (props: P, ref: ForwardedRef<T>): ReactElement | null;
+        (props: P, ref: ForwardedRef<T>): ReactNode;
         displayName?: string | undefined;
         // explicit rejected with `never` required due to
         // https://github.com/microsoft/TypeScript/issues/36826
@@ -3087,7 +3087,9 @@ declare namespace React {
         componentStack: string;
     }
 
+    // Keep in sync with JSX namespace in ./jsx-runtime.d.ts and ./jsx-dev-runtime.d.ts
     namespace JSX {
+        type ElementType = GlobalJSXElementType;
         interface Element extends GlobalJSXElement {}
         interface ElementClass extends GlobalJSXElementClass {}
         interface ElementAttributesProperty extends GlobalJSXElementAttributesProperty {}
@@ -3150,6 +3152,18 @@ declare global {
      * @deprecated Use `React.JSX` instead of the global `JSX` namespace.
      */
     namespace JSX {
+        // We don't just alias React.ElementType because React.ElementType
+        // historically does more than we need it to.
+        // E.g. it also contains .propTypes and so TS also verifies the declared
+        // props type does match the declared .propTypes.
+        // But if libraries declared their .propTypes but not props type,
+        // or they mismatch, you won't be able to use the class component
+        // as a JSX.ElementType.
+        // We could fix this everywhere but we're ultimately not interested in
+        // .propTypes assignability so we might as well drop it entirely here to
+        //  reduce the work of the type-checker.
+        // TODO: Check impact of making React.ElementType<P = any> = React.JSXElementConstructor<P>
+        type ElementType = string | React.JSXElementConstructor<any>;
         interface Element extends React.ReactElement<any, any> { }
         interface ElementClass extends React.Component<any> {
             render(): React.ReactNode;
@@ -3356,6 +3370,7 @@ declare global {
 // React.JSX needs to point to global.JSX to keep global module augmentations intact.
 // But we can't access global.JSX so we need to create these aliases instead.
 // Once the global JSX namespace will be removed we replace React.JSX with the contents of global.JSX
+type GlobalJSXElementType = JSX.ElementType;
 interface GlobalJSXElement extends JSX.Element {}
 interface GlobalJSXElementClass extends JSX.ElementClass {}
 interface GlobalJSXElementAttributesProperty extends JSX.ElementAttributesProperty {}
diff --git a/node_modules/@types/react/ts5.0/jsx-dev-runtime.d.ts b/node_modules/@types/react/ts5.0/jsx-dev-runtime.d.ts
index be717f4..62eaf2a 100755
--- a/node_modules/@types/react/ts5.0/jsx-dev-runtime.d.ts
+++ b/node_modules/@types/react/ts5.0/jsx-dev-runtime.d.ts
@@ -1,6 +1,7 @@
 import * as React from './';
 
 export namespace JSX {
+    type ElementType = React.JSX.ElementType;
     interface Element extends React.JSX.Element {}
     interface ElementClass extends React.JSX.ElementClass {}
     interface ElementAttributesProperty extends React.JSX.ElementAttributesProperty {}
diff --git a/node_modules/@types/react/ts5.0/jsx-runtime.d.ts b/node_modules/@types/react/ts5.0/jsx-runtime.d.ts
index be717f4..dc5ec6d 100755
--- a/node_modules/@types/react/ts5.0/jsx-runtime.d.ts
+++ b/node_modules/@types/react/ts5.0/jsx-runtime.d.ts
@@ -1,6 +1,7 @@
 import * as React from './';
 
 export namespace JSX {
+    type ElementType = React.JSX.ElementType;
     interface Element extends React.JSX.Element {}
     interface ElementClass extends React.JSX.ElementClass {}
     interface ElementAttributesProperty extends React.JSX.ElementAttributesProperty {}
