/* eslint-disable quotes */
import { existsSync, mkdirSync, rmSync, writeFileSync } from 'fs'
import path from 'path'
import prettierConf from '@graphcommerce/prettier-config-pwa'
import { transformFileSync } from '@swc/core'
import dotenv from 'dotenv'
import prettier from 'prettier'
import { loadConfig } from '../config/loadConfig'
import type { GraphCommerceConfig } from '../generated/config'
import { GraphCommerceConfigSchema } from '../generated/config'
import { resolveDependency } from '../utils/resolveDependency'

dotenv.config({ quiet: true })

const resolve = resolveDependency()

/** Keeps camelCase for file names and export names */
function toFileName(key: string): string {
  return key
}

/** Generates a TypeScript value literal for the given value */
function generateValueLiteral(value: unknown): string {
  if (value === null) return 'null'
  if (value === undefined) return 'undefined'
  if (typeof value === 'string') return JSON.stringify(value)
  if (typeof value === 'boolean' || typeof value === 'number') return String(value)
  if (Array.isArray(value) || (typeof value === 'object' && value !== null)) {
    return JSON.stringify(value, null, 2)
  }
  return JSON.stringify(value)
}

/** Checks if a value should get its own file (non-null objects only, not arrays) */
function shouldCreateFile(value: unknown): boolean {
  return typeof value === 'object' && value !== null && !Array.isArray(value)
}

/** Gets the schema keys for a specific config section */
function getSectionSchemaKeys(configKey: keyof GraphCommerceConfig): string[] {
  try {
    const mainSchema = GraphCommerceConfigSchema()
    const sectionSchema = mainSchema.shape[configKey]

    if (!sectionSchema) return []

    // Handle different schema wrapper types
    let unwrappedSchema = sectionSchema

    // Handle .nullish(), .optional(), .default() wrappers
    while (unwrappedSchema && typeof unwrappedSchema === 'object') {
      if ('_def' in unwrappedSchema) {
        // eslint-disable-next-line no-underscore-dangle
        const def = unwrappedSchema._def

        // Handle ZodOptional, ZodNullable, ZodDefault
        if ('innerType' in def && def.innerType) {
          unwrappedSchema = def.innerType
          // eslint-disable-next-line no-continue
          continue
        }

        // Handle ZodObject - this is what we want
        if ('typeName' in def && def.typeName === 'ZodObject' && 'shape' in def && def.shape) {
          return Object.keys((def.shape as () => Record<string, unknown>)())
        }

        break
      } else {
        break
      }
    }

    // Direct ZodObject
    if (unwrappedSchema && 'shape' in unwrappedSchema) {
      const shape =
        typeof unwrappedSchema.shape === 'function'
          ? (unwrappedSchema.shape as () => Record<string, unknown>)()
          : (unwrappedSchema.shape as Record<string, unknown>)
      return Object.keys(shape || {})
    }
  } catch {
    // Silently fail and return empty array
  }

  return []
}

/** Creates a configuration section file for nested objects */
async function createConfigSectionFile(
  sectionName: string,
  sectionValue: Record<string, unknown>,
  targetDir: string,
  targetDistDir: string,
  configKey: keyof GraphCommerceConfig,
): Promise<void> {
  const fileName = `${toFileName(sectionName)}.ts`
  const filePath = path.join(targetDir, fileName)
  const distFileName = `${toFileName(sectionName)}.js`
  const distFilePath = path.join(targetDistDir, distFileName)

  // Get all schema keys for this section to include all properties, even undefined ones
  const schemaKeys = getSectionSchemaKeys(configKey)

  // Create complete section object with schema defaults
  const completeSectionValue: Record<string, unknown> = {}
  for (const key of schemaKeys) {
    completeSectionValue[key] = sectionValue[key] // Use actual value if present, undefined if not
  }

  // Create individual exports for each property with proper typing
  const exports = Object.entries(completeSectionValue)
    .map(([key, value]) => {
      const valueStr = generateValueLiteral(value)
      const propertyPath = `'${sectionName}.${key}'`

      // Always include type annotation
      const typeAnnotation = `: Get<GraphCommerceConfig, ${propertyPath}>`

      return `export const ${key}${typeAnnotation} = ${valueStr}`
    })
    .join('\n\n')

  // Always need the Get import since we always use type annotations
  const needsGetImport = true

  const imports = needsGetImport
    ? `import type { GraphCommerceConfig } from '../config'\nimport type { Get } from 'type-fest'`
    : `import type { GraphCommerceConfig } from '../config'`

  const content = `// Auto-generated by 'yarn graphcommerce codegen-config-values'
${imports}

${exports}
`

  const formattedContent = await prettier.format(content, {
    ...prettierConf,
    parser: 'typescript',
    plugins: prettierConf.plugins?.filter(
      (p) => typeof p === 'string' && !p.includes('prettier-plugin-sort-imports'),
    ),
  })

  // Write TypeScript file
  writeFileSync(filePath, formattedContent)

  // Transform and write JavaScript file
  const result = transformFileSync(filePath, {
    module: { type: 'nodenext' },
    env: { targets: { node: '18' } },
  })

  writeFileSync(distFilePath, result.code)
}

export async function generateConfigValues() {
  const resolved = resolve('@graphcommerce/next-config')
  if (!resolved) throw Error('Could not resolve @graphcommerce/next-config')

  const config = loadConfig(process.cwd())
  const targetDir = `${resolved.root}/src/generated/configValues`
  const targetDistDir = `${resolved.root}/dist/generated/configValues`

  // Clean up existing directories and recreate them
  if (existsSync(targetDir)) {
    rmSync(targetDir, { recursive: true, force: true })
  }
  if (existsSync(targetDistDir)) {
    rmSync(targetDistDir, { recursive: true, force: true })
  }
  mkdirSync(targetDir, { recursive: true })
  mkdirSync(targetDistDir, { recursive: true })

  // Get all schema keys to ensure we include everything, even undefined values
  const schema = GraphCommerceConfigSchema()
  const schemaKeys = Object.keys(schema.shape) as (keyof GraphCommerceConfig)[]

  // Create a complete config object with schema defaults
  const completeConfig: Record<string, unknown> = {}
  for (const key of schemaKeys) {
    completeConfig[key] = config[key] // Use actual value if present, undefined if not
  }

  const configEntries = Object.entries(completeConfig) as [keyof GraphCommerceConfig, unknown][]
  const nestedObjects: [string, Record<string, unknown>, keyof GraphCommerceConfig][] = []
  const rootExports: string[] = []

  // Separate nested objects from root-level values
  for (const [key, value] of configEntries) {
    if (shouldCreateFile(value)) {
      // Create file for nested object
      nestedObjects.push([key, value as Record<string, unknown>, key])
      rootExports.push(`export * as ${key} from './${toFileName(key)}'`)
    } else {
      // Add to root exports (including undefined values)
      const valueStr = generateValueLiteral(value)
      // Always include type annotation
      const typeAnnotation = `: Get<GraphCommerceConfig, '${key}'>`
      rootExports.push(`export const ${key}${typeAnnotation} = ${valueStr}`)
    }
  }

  // Create files for nested objects
  await Promise.all(
    nestedObjects.map(([sectionName, sectionValue, configKey]) =>
      createConfigSectionFile(sectionName, sectionValue, targetDir, targetDistDir, configKey),
    ),
  )

  // Always need the Get import since we always use type annotations
  const rootNeedsGetImport = true

  const rootImports = rootNeedsGetImport
    ? `import type { GraphCommerceConfig } from '../config'\nimport type { Get } from 'type-fest'`
    : `import type { GraphCommerceConfig } from '../config'`

  // Create the main index file
  const indexContent = `// Auto-generated by 'yarn graphcommerce codegen-config-values'
${rootImports}

${rootExports.join('\n')}
`

  const formattedIndexContent = await prettier.format(indexContent, {
    ...prettierConf,
    parser: 'typescript',
    plugins: prettierConf.plugins?.filter(
      (p) => typeof p === 'string' && !p.includes('prettier-plugin-sort-imports'),
    ),
  })

  const indexPath = path.join(targetDir, 'index.ts')
  const distIndexPath = path.join(targetDistDir, 'index.js')

  // Write TypeScript index file
  writeFileSync(indexPath, formattedIndexContent)

  // Transform and write JavaScript index file
  const indexResult = transformFileSync(indexPath, {
    module: { type: 'nodenext' },
    env: { targets: { node: '20' } },
  })

  writeFileSync(distIndexPath, indexResult.code)

  // eslint-disable-next-line no-console
  console.log(`‚úÖ Generated config values in ${targetDir} and ${targetDistDir}`)
  // eslint-disable-next-line no-console
  console.log(`üìÅ Created ${nestedObjects.length} nested object files + index.ts/.js`)
  // eslint-disable-next-line no-console
  console.log(`üìù Root exports: ${configEntries.length - nestedObjects.length}`)
}
