import fs from 'node:fs/promises'
import path from 'node:path'
import dotenv from 'dotenv'
import { sync as globSync } from 'glob'
import { resolveDependenciesSync } from '../../utils/resolveDependenciesSync'

dotenv.config()

function checkFileExists(file: string) {
  return fs
    .access(file, fs.constants.F_OK)
    .then(() => true)
    .catch(() => false)
}

/**
 * Cleanup all interceptors by restoring original files and removing generated interceptors. This
 * command will:
 *
 * 1. Find all .original files and restore them to their original names
 * 2. Remove any remaining .interceptor files
 * 3. Clean up generated interceptor files (but only in packages/, not packagesDev/)
 */
export async function cleanupInterceptors(cwd: string = process.cwd()) {
  console.info('ğŸ§¹ Starting interceptor cleanup...')

  const dependencies = resolveDependenciesSync(cwd)
  let restoredCount = 0
  let removedCount = 0

  // Find all .original files and restore them
  const originalFiles: string[] = []
  dependencies.forEach((dependency) => {
    // Skip node_modules dependencies
    if (dependency.includes('node_modules')) return

    const files = globSync([`${dependency}/**/*.original.tsx`, `${dependency}/**/*.original.ts`], {
      cwd,
    })
    originalFiles.push(...files)
  })

  console.info(`ğŸ“‚ Found ${originalFiles.length} .original files to restore`)

  // Restore .original files
  const restorePromises = originalFiles.map(async (originalFile) => {
    const fullOriginalPath = path.join(cwd, originalFile)
    const restoredPath = fullOriginalPath.replace(/\.original\.(tsx?)$/, '.$1')

    try {
      if (await checkFileExists(fullOriginalPath)) {
        // Remove the current interceptor file if it exists
        if (await checkFileExists(restoredPath)) {
          await fs.unlink(restoredPath)
        }

        // Restore the original file
        await fs.rename(fullOriginalPath, restoredPath)
        restoredCount++
        console.info(`âœ… Restored: ${originalFile.replace('.original.', '.')}`)
      }
    } catch (error) {
      console.error(`âŒ Failed to restore ${originalFile}:`, error)
    }
  })

  await Promise.all(restorePromises)

  // Find and remove any remaining .interceptor files
  const interceptorFiles: string[] = []
  dependencies.forEach((dependency) => {
    // Skip node_modules dependencies
    if (dependency.includes('node_modules')) return

    const files = globSync(
      [`${dependency}/**/*.interceptor.tsx`, `${dependency}/**/*.interceptor.ts`],
      { cwd },
    )
    interceptorFiles.push(...files)
  })

  console.info(`ğŸ—‘ï¸  Found ${interceptorFiles.length} .interceptor files to remove`)

  const removeInterceptorPromises = interceptorFiles.map(async (interceptorFile) => {
    const fullPath = path.join(cwd, interceptorFile)

    try {
      if (await checkFileExists(fullPath)) {
        await fs.unlink(fullPath)
        removedCount++
        console.info(`ğŸ—‘ï¸  Removed: ${interceptorFile}`)
      }
    } catch (error) {
      console.error(`âŒ Failed to remove ${interceptorFile}:`, error)
    }
  })

  await Promise.all(removeInterceptorPromises)

  // Find and remove generated interceptor files in packages/ only (skip packagesDev)
  // We only check files that contain the generated interceptor markers
  const allFiles: string[] = []
  dependencies.forEach((dependency) => {
    // Only check packages/, skip node_modules and packagesDev (our source code)
    if (
      dependency.includes('node_modules') ||
      dependency.includes('packagesDev') ||
      !dependency.startsWith('packages/')
    )
      return

    const files = globSync([`${dependency}/**/*.tsx`, `${dependency}/**/*.ts`], {
      cwd,
      ignore: ['**/*.original.*', '**/*.interceptor.*', '**/node_modules/**'],
    })
    allFiles.push(...files)
  })

  console.info(`ğŸ” Checking ${allFiles.length} files for generated interceptors...`)

  const cleanupGeneratedPromises = allFiles.map(async (file) => {
    const fullPath = path.join(cwd, file)

    try {
      if (await checkFileExists(fullPath)) {
        const content = await fs.readFile(fullPath, 'utf8')

        // Check if this is a generated interceptor file by looking for our specific markers
        const hasHashComment = content.includes('/* hash:')
        const hasGeneratedComment = content.includes('/* This file is automatically generated')
        const isGeneratedInterceptor = hasHashComment && hasGeneratedComment

        if (isGeneratedInterceptor) {
          await fs.unlink(fullPath)
          removedCount++
          console.info(`ğŸ—‘ï¸  Removed generated interceptor: ${file}`)
        }
      }
    } catch (error) {
      console.error(`âŒ Failed to check/remove ${file}:`, error)
    }
  })

  await Promise.all(cleanupGeneratedPromises)

  console.info('')
  console.info('âœ… Interceptor cleanup completed!')
  console.info(`ğŸ“Š Summary:`)
  console.info(`   - ${restoredCount} files restored from .original`)
  console.info(`   - ${removedCount} interceptor files removed`)
  console.info('')
  console.info(
    'ğŸ’¡ You can now run "yarn graphcommerce codegen-interceptors" to regenerate interceptors',
  )
}
