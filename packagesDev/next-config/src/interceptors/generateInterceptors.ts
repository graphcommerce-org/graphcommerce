import path from 'node:path'
import { ResolveDependency, ResolveDependencyReturn } from '../utils/resolveDependency'

type PluginBaseConfig = {
  exported: string
  plugin: string
  enabled: boolean
  ifConfig?: string
}
export function isPluginBaseConfig(plugin: Partial<PluginBaseConfig>): plugin is PluginBaseConfig {
  return (
    typeof plugin.exported === 'string' &&
    typeof plugin.plugin === 'string' &&
    typeof plugin.enabled === 'boolean'
  )
}

type ReactPluginConfig = PluginBaseConfig & { component: string }
type MethodPluginConfig = PluginBaseConfig & { method: string }

export function isReactPluginConfig(
  plugin: Partial<PluginBaseConfig>,
): plugin is ReactPluginConfig {
  if (!isPluginBaseConfig(plugin)) return false
  return (plugin as ReactPluginConfig).component !== undefined
}

export function isMethodPluginConfig(
  plugin: Partial<PluginBaseConfig>,
): plugin is MethodPluginConfig {
  if (!isPluginBaseConfig(plugin)) return false
  return (plugin as MethodPluginConfig).method !== undefined
}

export type PluginConfig = ReactPluginConfig | MethodPluginConfig
export function isValidPlugin(plugin: Partial<PluginConfig>): plugin is PluginConfig {
  return isReactPluginConfig(plugin) || isMethodPluginConfig(plugin)
}

type Interceptor = ResolveDependencyReturn & {
  components: Record<string, PluginConfig[]>
  target: string
  template?: string
}

export type MaterializedPlugin = Interceptor & { template: string }

function moveRelativeDown(plugins: PluginConfig[]) {
  return [...plugins].sort((a, b) => {
    if (a.plugin.startsWith('.') && !b.plugin.startsWith('.')) return 1
    if (!a.plugin.startsWith('.') && b.plugin.startsWith('.')) return -1
    return 0
  })
}

export function generateInterceptor(interceptor: Interceptor): MaterializedPlugin {
  const { fromModule, dependency, components } = interceptor

  const flattended = Object.entries(components)
    .map(([, plugins]) => plugins)
    .flat()
  const duplicateImports = new Set()

  const pluginImports = moveRelativeDown(
    [...flattended].sort((a, b) => a.plugin.localeCompare(b.plugin)),
  )
    .map((p) => p.plugin)
    .map((p) => `import { Plugin as ${p.split('/')[p.split('/').length - 1]} } from '${p}'`)
    .filter((str) => {
      if (duplicateImports.has(str)) return false
      duplicateImports.add(str)
      return true
    })
    .join('\n')

  const imports = Object.entries(components).map(
    ([component]) => `${component} as ${component}Base`,
  )
  const importInjectables =
    imports.length > 1
      ? `import { 
  ${imports.join(',\n  ')},
} from '${fromModule}'`
      : `import { ${imports[0]} } from '${fromModule}'`

  const pluginExports = Object.entries(components)
    .map(([component, plugins]) => {
      const duplicateInterceptors = new Set()

      let carry = `${component}Base`
      const pluginStr = plugins
        .reverse()
        .map((p) => p.plugin.split('/')[p.plugin.split('/').length - 1])
        .filter((importStr) => {
          if (duplicateInterceptors.has(importStr)) {
            return false
          }
          duplicateInterceptors.add(importStr)
          return true
        })
        .map((name) => {
          const result = `function ${name}Interceptor(props: ${component}Props) {
  return <${name} {...props} Prev={${carry}} />
}`
          carry = `${name}Interceptor`
          return result
        })
        .join('\n')

      return `
/**
 * Interceptor for \`<${component}/>\` with these plugins:
 * 
${plugins.map((p) => ` * - \`${p.plugin}\``).join('\n')}
 */
type ${component}Props = ComponentProps<typeof ${component}Base>

${pluginStr}
export const ${component} = ${carry}`
    })
    .join('\n')

  const componentExports = `export * from '${fromModule}'`

  const template = `/* This file is automatically generated for ${dependency} */

${componentExports}
${pluginImports}
import { ComponentProps } from 'react'
${importInjectables}
${pluginExports}
`

  return { ...interceptor, template }
}

export type GenerateInterceptorsReturn = Record<string, MaterializedPlugin>

export function generateInterceptors(
  plugins: PluginConfig[],
  resolve: ResolveDependency,
): GenerateInterceptorsReturn {
  // todo: Do not use reduce as we're passing the accumulator to the next iteration
  const byExportedComponent = moveRelativeDown(plugins).reduce((acc, plug) => {
    const { exported, component, enabled, plugin } = plug
    if (!exported || !component || !enabled) return acc

    const resolved = resolve(exported)

    let pluginPathFromResolved = plugin
    if (plugin.startsWith('.')) {
      const resolvedPlugin = resolve(plugin)
      pluginPathFromResolved = path.relative(
        resolved.fromRoot.split('/').slice(0, -1).join('/'),
        resolvedPlugin.fromRoot,
      )
    }

    if (!acc[resolved.fromRoot])
      acc[resolved.fromRoot] = {
        ...resolved,
        target: `${resolved.fromRoot}.interceptor`,
        components: {},
      } as Interceptor

    if (!acc[resolved.fromRoot].components[component])
      acc[resolved.fromRoot].components[component] = []

    acc[resolved.fromRoot].components[component].push({
      ...plug,
      plugin: pluginPathFromResolved,
    })

    return acc
  }, {} as Record<string, Interceptor>)

  return Object.fromEntries(
    Object.entries(byExportedComponent).map(([target, interceptor]) => [
      target,
      generateInterceptor(interceptor),
    ]),
  )
}
